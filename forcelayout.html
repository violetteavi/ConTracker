<!DOCTYPE html>
<meta charset="utf-8">
<style>

.link {
  stroke: #000;
  stroke-width: 1.5px;
}

.node {
  cursor: move;
  fill: #ccc;
  stroke: #000;
  stroke-width: 1.5px;
}

.node.fixed {
  fill: #f00;
}

</style>
<body>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script>

var width = 960,
    height = 500,
	maxRadius = 30,
	minRadius = 5,
	padding = 1.5;
/*
var nodes = [
    {"x": 469, "y": 410},
    {"x": 493, "y": 364},
    {"x": 442, "y": 365},
    {"x": 467, "y": 314},
    {"x": 477, "y": 248},
    {"x": 425, "y": 207},
    {"x": 402, "y": 155, "fixed":true},
    {"x": 369, "y": 196, "fixed":true},
    {"x": 350, "y": 148, "fixed":true},
    {"x": 539, "y": 222, "fixed":true},
    {"x": 594, "y": 235, "fixed":true},
    {"x": 582, "y": 185, "fixed":true}
  ];
var links = [
    {"source":  0, "target":  6},
    {"source":  1, "target":  7},
    {"source":  2, "target":  8},
    {"source":  3, "target":  9},
    {"source":  4, "target":  10},
    {"source":  5, "target":  11}
  ];
 *///*
 var numNodes = 50;
 var nodes = [];
 var links = [];
 var genIndex;
 for(genIndex = 0; genIndex < numNodes; genIndex++) {
    var sizeScale = Math.random();
    var radius = (minRadius + sizeScale*(maxRadius-minRadius));
	var xStart = (1+3*sizeScale)*width*0.2;
	var yStart = (-0.015+.03*Math.random() + 0.5)*height;
	nodes.push({"x":xStart, "y":yStart, "radius":radius, "fixed":true, "anchor":true});
	nodes.push({"x":xStart, "y":yStart, "radius":radius});
	links.push({"source":  2*genIndex, "target":  2*genIndex+1});
 }
//*/
var force = d3.layout.force()
    .size([width, height])
    .charge(0)
	.gravity(0)
    .linkDistance(1)
    .linkStrength(0.5)
    .on("tick", tick);

var drag = force.drag()
    .on("dragstart", dragstart);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var link = svg.selectAll(".link"),
    node = svg.selectAll(".node");

force
    .nodes(nodes)
    .links(links)
    .start();

link = link.data(links)
  //.enter().append("line")
    //.attr("class", "link");

node = node.data(nodes)
  .enter().append("circle")
    .attr("class", "node")
    .attr("r", function(node){
		if(node.fixed === true) return 0;
        return node.radius;
	})
    .on("dblclick", dblclick)
    .call(drag);

function tick() {
  link.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

  node.each(collide(0.5));
  node.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
}

function dblclick(d) {
  d3.select(this).classed("fixed", d.fixed = false);
}

function dragstart(d) {
  //d3.select(this).classed("selected", d.selected = true);
}

// from user Cool Blue at: https://stackoverflow.com/questions/32988306/how-to-simulate-mouse-move-in-d3-so-when-you-drag-nodes-other-nodes-move-automa/32998608#32998608
function positionnodes(){
        var ns = "CB:emit/drag/transition/or-whatever-you-feel-like",
            shadowNodes = d3.select("body").selectAll("emitDrag")
                .data(nodes.filter(function(d){return d.fixed})),
            shadowedData = [];
        shadowNodes.enter().append(function(){return document.createElementNS(ns, "emitDrag")});

        shadowNodes.each(function(d, i){
            var n = d3.select(this);
            shadowedData[i] = d;
            dragstart.call(node.filter(function(s){return s === d;}).node(), d);

            d.fixed = true;
            n.attr({cx: d.x, cy: d.y});

            Object.defineProperties(d, {
                px: {
                    get: function() {return +n.attr("cx")},
                    configurable: true
                },
                py: {
                    get: function() {return +n.attr("cy")},
                    configurable: true
                }
            });
        });

        force.start();

        d3.range(1).reduce(function(o, s){
            return o.transition().duration(750).ease("cubic")
                    .attr({
                        cx: function(){return (1+3*Math.random())*width*0.2},
                        cy: function(){return (-0.015+.03*Math.random() + 0.5)*height}
                    })
        },shadowNodes)
            .each("end", function(d, i){
                var n = d3.select(this);
                Object.defineProperties(shadowedData[i], {
                    px: {value: +n.attr("cx"), writable: true},
                    py: {value: +n.attr("cy"), writable: true}
                });
            });
 }
 
 // Resolves collisions between d and all other circles.
 // adapted from https://bl.ocks.org/mbostock/1748247
function collide(alpha) {
  var quadtree = d3.geom.quadtree(nodes.filter(function(d){return !d.fixed}));
  return function(d) {
    if(d.anchor) return true;
    var r = d.radius + maxRadius + padding,
        nx1 = d.x - r,
        nx2 = d.x + r,
        ny1 = d.y - r,
        ny2 = d.y + r;
    quadtree.visit(function(quad, x1, y1, x2, y2) {
      if (quad.point && (quad.point !== d)) {
        var x = d.x - quad.point.x,
            y = d.y - quad.point.y,
            l = Math.sqrt(x * x + y * y),
            r = d.radius + quad.point.radius + padding;
        if (l < r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          quad.point.x += x;
          quad.point.y += y;
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    });
  };
}


setInterval(function() {
    positionnodes();
}, 50000);

</script>
